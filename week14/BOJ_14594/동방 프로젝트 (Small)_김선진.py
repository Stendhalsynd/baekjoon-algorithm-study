"""
Input: N(동아리 방의 개수) / M(빅-종빈빌런의 행동 횟수) / x, y(빅-종빈빌런의 행동)
Output: 빅-종빈빌런의 모든 행동이 끝난 후 남아있는 동방의 개수
Constraints: 2 <= N <= 100 / 0 <= M <= 100 / 1 <= x < y <= N

문제 정리:
N개의 방 일직 선상에 존재, 맨 왼쪽 방의 번호는 1번 ~ 맨 오른쪽 방의 번호 N번
빅-종빈빌런이 건물 벽을 허무는 규칙
- x < y를 만족하는 두 방에 대해서 x번 방부터 y번 방 사이에 있는 모든 벽을 허문다.
- 이미 허물어진 벽이 존재한다면 무시하고 다음 벽을 허문다.
- 1번 방의 왼쪽 벽과 N번 방의 오른쪽 벽은 허물지 않는다.
남아있는 동방의 개수 -> 병찬이는 동아리 방을 얻을 수 있는지에 대한 확률 계산

풀이:
1. 초기에 모든 방들의 벽을 0으로 초기화한다.
2. 이후 M개에 대한 범위를 입력 받아 x부터 y-1까지 1로 표시한다.
3. M번의 반복이 종료된다면 0의 개수 카운트

예제)
N = 5
M = 2
rooms = [0, 0, 0, 0, 0, 0]

x = 1, y = 2
rooms = [0, 1, 0, 0, 0, 0]

x = 2, y = 4
rooms = [0, 1, 1, 1, 0, 0]

answer = 3
-> 2 출력

시간 복잡도: rooms배열 생성: O(N), O(M * (y - x)) -> N의 크기가 선형적으로 증가한다는 가정 하에, 최악의 경우 -> O(N^2)
공간 복잡도: rooms 배열의 크기에 N에 비례 -> O(N)
"""
import sys
input = sys.stdin.readline

N = int(input())
M = int(input())
rooms = [0] * (N + 1) # 모든 방들의 벽을 0
for _ in range(M):
  x, y = map(int, input().split())
  for room in range(x, y):
    rooms[room] = 1
  
answer = rooms.count(0)
print(answer-1)